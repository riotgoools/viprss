{"title":"Neat npm modules - Vol 1","link":"https://blog.webb.page/2019-01-02-neat-npm-01.txt","date":1546387200000,"content":"<p>This is the first post in what will become a series of posts about interesting\nand useful npm modules I come across and/or use in my projects.</p>\n<p>Over the past year, small modules that got to the point and had close to zero\ndependencies (dependency-free is even better!) became more appealing to me for\na few reasons.</p>\n<ol>\n<li>Big modules are slow to update. When a vulnerability is found in one of\ntheir dependencies the module maintainers are notified and then‚Ä¶nothing.\nSometimes the maintainers never respond so someone forks the project,\nupdates the dependencies, and pushes that project under a new name. When\nsecurity issues are discovered, I want them resolved ASAP. Smaller modules\nhave less attack area, obviously. Fewer moving parts, &amp;c.</li>\n<li>The left-pad incident<a href=\"https://blog.npmjs.org/post/141577284765/kik-left-pad-and-npm\">1</a> and similarly befuddling things happening in the\nnpm ecosphere give me pause about relying on a module with a bajillion\nmoving parts. TL;DR: A popular module used by <em>thousands</em> of other modules\nwas unpublished (removed) from npm and that caused QUITE the fuss when\nroutine <code>npm install</code>s went off the rails across the Internet.</li>\n</ol>\n<p>Please note that <code>package.json</code> examples below only have the necessary\nparameters regarding the section its in. This is for brevity. New developers\ncome into being every day I'd like to help them out by removing possible\nconfusion.</p>\n<h2>colorette</h2>\n<blockquote>\n<p>Colorette is a Node.js library for colorizing text in terminals.</p>\n</blockquote>\n<p>Most people just use chalk<a href=\"https://www.npmjs.com/package/chalk\">2</a> to style terminal text and I did too. When I saw\nI could get the same functionality in a smaller dependency-free package, I\njumped at the chance to use it. chalk does and supports a lot more but for\n<em>my</em> needs, colorette is juuuuust fine.</p>\n<p>Find it on npm<a href=\"https://www.npmjs.com/package/colorette\">3</a> | GitHub<a href=\"https://github.com/jorgebucaran/colorette\">4</a></p>\n<h2>husky</h2>\n<blockquote>\n<p>Husky can prevent bad git commit, git push and more üê∂ woof!</p>\n</blockquote>\n<p>I'm honestly <em>embarrassed</em> that I haven't used something like husky earlier in\nlife. Husky saves you from <em>yourself</em> and what a beautiful job it does. Here's\nhow I use it in my <code>package.json</code>:</p>\n<pre><code>\"husky\": {\n  \"hooks\": {\n    \"pre-commit\": \"npm run format &amp;&amp; npm run test:sass &amp;&amp; git add -A :/\"\n  }\n},\n\"scripts\": {\n  \"format\": \"eslint '*/*.js' --fix --ignore-pattern '/app/dist/'\",\n  \"test:sass\": \"sass-lint --config ./node_modules/@inc/sasslint-config/config.json --verbose --no-exit\"\n}\n</code></pre>\n<p>What my pre-commit hook does is:</p>\n<ol>\n<li>Use eslint to automatically format issues in JavaScript files found in the\ncodebase, except for JavaScript files in the folder <code>/app/dist/</code>.</li>\n<li>Use sass-lint and a custom configuration file to find issues in Sass files\nfound in the codebase.</li>\n<li>Stage (prepare) the changed files, if any, to be committed to my git server\n(I self-host with Gitea but this works with any git server).</li>\n</ol>\n<p>Find it on npm<a href=\"https://www.npmjs.com/package/husky\">5</a> | GitHub<a href=\"https://github.com/typicode/husky\">6</a></p>\n<h2>npm-run-all</h2>\n<blockquote>\n<p>A CLI tool to run multiple npm-scripts in parallel or sequential.</p>\n</blockquote>\n<p>Here's how I use it in my <code>package.json</code>:</p>\n<pre><code>\"scripts\": {\n  \"test\": \"run-s test:*\",\n  \"test:dependencies\": \"updates --update ./ --exclude fastify\",\n  \"test:lint\": \"standardx --verbose | snazzy\",\n  \"test:sass\": \"sass-lint --config ./node_modules/@inc/sasslint-config/config.json --verbose --no-exit\",\n  \"watch\": \"run-p watch:*\",\n  \"watch:sass\": \"sass --watch app/sass:app/dist --style compressed\",\n  \"watch:server\": \"NODE_ENV=development nodemon server\"\n}\n</code></pre>\n<p><code>run-s</code> runs scripts sequentially, whereas <code>run-p</code> runs scripts in parallel.\nYou've probably guessed by now but <code>run-s test:*</code> tells npm-run-all to run any\nscript with \"test:\", one after the other. <code>run-p watch:*</code> tells it run any\nscript with \"watch:\", side by side. I like it a lot.</p>\n<p>Find it on npm<a href=\"https://www.npmjs.com/package/npm-run-all\">7</a> | GitHub<a href=\"https://github.com/mysticatea/npm-run-all\">8</a></p>\n<h2>updates</h2>\n<blockquote>\n<p>Fast npm dependency updating tool</p>\n</blockquote>\n<p>I found updates after being frustrated with npm-check-updates<a href=\"https://www.npmjs.com/package/npm-check-updates\">9</a>. One of the\nmaintainers of the latter was uninterested<a href=\"https://github.com/tjunnone/npm-check-updates/issues/432\">10</a> in updating the dependencies.\nForking and working on npm-check-updates myself proved to be annoying so I\nwent looking for solutions elsewhere.</p>\n<p>Here's how I use it in my <code>package.json</code> (fastify is working on their next\nversion and it's messing with this script so I ignore updating it for now):</p>\n<pre><code>\"scripts\": {\n  \"test:dependencies\": \"updates --update ./ --exclude fastify\"\n}\n</code></pre>\n<p>Find it on npm<a href=\"https://www.npmjs.com/package/updates\">11</a> | GitHub<a href=\"https://github.com/silverwind/updates\">12</a></p>\n<h2>ver</h2>\n<blockquote>\n<p>Increment semantic versions across your project. Intended for projects with\na package.json, but works with other files too. Will create a git commit and\ntag by default. By default, only the nearest package.json file is modified.</p>\n</blockquote>\n<p>Before ver, I never cared about \"semantic versioning\", let alone versioning\n<em>itself</em>. ver makes it super low effort to do. I just run\n<code>ver patch|minor|major</code> and chain it with other commands. It will\nautomatically update the \"version\" field in your <code>package.json</code> file.\nPretty sweet.</p>\n<p>My typical usage is something like:</p>\n<pre><code>ver patch &amp;&amp; git push &amp;&amp; npm publish\n</code></pre>\n<p>Find it on npm<a href=\"https://www.npmjs.com/package/ver\">13</a> | GitHub<a href=\"https://github.com/silverwind/ver\">14</a></p>\n<h2>FIN</h2>\n<p>And there you have it! Five neat modules I find incredibly useful. I hope you\ndo too! üï∏</p>\n<hr />\n","author":"","siteTitle":"the webb blog","siteHash":"d87386c8de21b16d23a4d22ceb0991728c5b4e4486d627490c6fcde14e563300","entryHash":"49b3df2b764c899381a335da9d719f8319cb8ca9d93c874a6291f190e937ff1d","category":"Sites"}