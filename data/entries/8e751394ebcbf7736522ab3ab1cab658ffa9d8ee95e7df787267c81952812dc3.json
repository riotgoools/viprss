{"title":"Database trigger recalculates totals, for data integrity","link":"https://sive.rs/recalc","date":1645920000000,"content":"<p>\nWhen you make a database-backed app, you write code to ensure data integrity in related fields.\n</p><p>\nIf an item is sold, you update the inventory.\nIf someone withdraws money, you update their balance.\nYou recalcuate the total and update the related field in the database whenever somebody makes a change.\n</p><p>\nUsually this is done in your main code: your JavaScript, Python, Ruby, Java, or whatever.\n</p><p>\n<strong>\nBut what if some future code doesn’t use your currently-crucial function?\n</strong>\nA new back-end interface, API hook, or simple shell script might not use your current code.\nNew code will access the database directly, not using your old code.\n</p><p>\nI encountered this exact situation at my last company, and felt the pain from inventory and even finances becoming wrong, all because some new code was accessing the database directly.\n</p><p>\nSo that’s why I’m an evangelist now for how important it is to <strong>put your crucial code in the database itself</strong>.\nThis is <strong>data logic</strong> (not “business logic”) and <strong>should be bound to the data</strong>.\nDatabase functions can be triggered, ensuring integrity, no matter what outside code is accessing it.\n</p><h3>\nHere’s an example in PostgreSQL, using a shopping cart:\n</h3><p>\nFirst, make three simple tables:\n</p><ol><li>\nItems with prices.\n</li><li>\nLineitems with quantities.\n</li><li>\nInvoices with the total price.\n</li></ol><p>\nCreate two example items, a $5 and a $9 item.\nAnd create invoice #1 for testing.\n</p>\n<div>\n<pre><code>create table items (\n  id serial primary key,\n  price int not null check (price &gt; 0)\n);\n\ncreate table invoices (\n  id serial primary key,\n  total int\n);\n\ncreate table lineitems (\n  invoice_id int not null references invoices(id),\n  item_id int not null references items(id),\n  quantity int not null check (quantity &gt; 0),\n  primary key (invoice_id, item_id)\n);\n\n-- example data:\ninsert into items (price) values (5);\ninsert into items (price) values (9);\ninsert into invoices (total) values (0);\n</code></pre><small><a href=\"https://sive.rs/code/recalc-1.sql\">download code</a></small>\n</div>\n<p>\nNow, you want it to re-calculate the Invoice total whenever Lineitems are changed.\nThat’s a special function called a <strong>trigger</strong>.\nFirst you create the function, then create a trigger that executes the function.\n</p>\n<div>\n<pre><code>-- re-calculate the total of a lineitem's invoice\ncreate function recalc() returns trigger as $$\nbegin\n  -- update invoice using lineitems's invoice_id\n  update invoices set total = (\n    select sum(quantity * price)\n    from lineitems\n    join items on lineitems.item_id = items.id\n    where invoice_id = new.invoice_id)\n  where id = new.invoice_id;\n  return new;\nend;\n$$ language plpgsql;\n-- run this function after any change to lineitems\ncreate trigger recalc\n  after insert or update or delete on lineitems\n  for each row execute procedure recalc();\n</code></pre><small><a href=\"https://sive.rs/code/recalc-2.sql\">download code</a></small>\n</div>\n<p>\nTest it by adding Lineitems, and updating their quantities.\nAfter each change, look at the Invoice.\nIt works!\n</p>\n<div>\n<pre><code>insert into lineitems (invoice_id, item_id, quantity) values (1, 1, 1);\ninsert into lineitems (invoice_id, item_id, quantity) values (1, 2, 1);\nselect * from lineitems; select * from invoices;\n\nselect 'Notice new total when you update quantity:' look;\nupdate lineitems set quantity = 5 where invoice_id = 1 and item_id = 2;\nselect * from lineitems; select * from invoices;\n\nselect 'But when you delete a line? Oh no. Total is still $50' look;\ndelete from lineitems where invoice_id = 1 and item_id = 2;\nselect * from lineitems; select * from invoices;\n\n-- Let's try again in recalc-4.sql\ndrop function recalc() cascade;\n</code></pre><small><a href=\"https://sive.rs/code/recalc-3.sql\">download code</a></small>\n</div>\n<p>\nBut notice if you delete a Lineitem, it doesn’t update the Invoice!\nWhat the hell?\nWhy not?\n</p><p>\nAh, that’s because the function refers to a record variable called “new”, passed by the trigger on Lineitems, and uses it to get the invoice_id.\nBut when when you delete a Lineitem, the record variable is called “old”, since it refers to a Lineitem that’s already been deleted.\nDamn.\n</p><p>\nYou could make two separate triggers, one that uses “new”, called only on update and insert operations, and one that uses “old”, called only on deletes.\nBut then you’d be duplicating the calculation of the total.\nSo instead, just add one ugly if/then to assign either “new” or “old” to a variable called “r”, and use “r” instead.\nHere’s the updated function:\n</p>\n<div>\n<pre><code>-- re-calculate the total of a lineitem's invoice\ncreate function recalc() returns trigger as $$\ndeclare\n  r record;\nbegin\n  -- use \"new\" lineitems record for insert/update, or \"old\" if delete\n  if (tg_op = 'DELETE') then\n    r = old;\n  else\n    r = new;\n  end if;\n  -- update invoice using lineitems(now \"r\")'s invoice_id\n  update invoices set total = (\n    select sum(quantity * price)\n    from lineitems\n    join items on lineitems.item_id = items.id\n    where invoice_id = r.invoice_id)\n  where id = r.invoice_id;\n  -- must return incoming \"new\" or \"old\" record when done\n  return r;\nend;\n$$ language plpgsql;\n-- run this function after any change to lineitems\ncreate trigger recalc\n  after insert or update or delete on lineitems\n  for each row execute procedure recalc();\n</code></pre><small><a href=\"https://sive.rs/code/recalc-4.sql\">download code</a></small>\n</div>\n<p>\nNow test adding, updating, and deleting, and notice they all update the Invoice total:\n</p>\n<div>\n<pre><code>insert into lineitems (invoice_id, item_id, quantity) values (1, 2, 1);\nselect * from lineitems; select * from invoices;\n\nselect 'Notice new total when you update quantity:' look;\nupdate lineitems set quantity = 5 where invoice_id = 1 and item_id = 2;\nselect * from lineitems; select * from invoices;\n\nselect 'Notice new total when you delete:' look;\ndelete from lineitems where invoice_id = 1 and item_id = 2;\nselect * from lineitems; select * from invoices;\n</code></pre><small><a href=\"https://sive.rs/code/recalc-5.sql\">download code</a></small>\n</div>\n<p>\nCool?\nYou get <strong>much more security and peace-of-mind</strong>, knowing that no matter what code updates your database, the related fields will be updated automatically.\n</p><p>\nDownload the final example file here: <a href=\"https://sive.rs/code/recalc.sql\">/code/recalc.sql</a>.\n</p><p>\nAfter you get this example working, let’s try another example of putting data logic in the database, by <a href=\"https://sive.rs/api01\">making functions for updating the cart</a>.\n</p><p>\nAlso look at <a href=\"https://sive.rs/clean1\">using triggers to clean incoming data</a>.\n</p>\n","author":"Derek Sivers","siteTitle":"Derek Sivers","siteHash":"4098504c0d0759e13901f29e63f7d7dbb1d972a078c6dc4560660f373da5c25e","entryHash":"8e751394ebcbf7736522ab3ab1cab658ffa9d8ee95e7df787267c81952812dc3","category":"Sites"}