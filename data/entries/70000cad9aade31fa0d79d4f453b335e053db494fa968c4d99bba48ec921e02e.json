{"title":"Static HTML comments","link":"https://sive.rs/shc","date":1665187200000,"content":"<p>\nIf you have a static HTML website, but you want to include comments, here’s an interesting way to do it using PostgreSQL’s NOTIFY and LISTEN.\n</p><p>\nThe big idea is to <strong>write the comments as static HTML, only when comments change</strong>, instead of doing a database query to display them every time.\nThis prevents the “hug of death” if you get a burst of traffic.\n</p><p>\nI’ve been doing it this way for over six years, and it works great.\nHere’s the recipe, using Ruby as the glue, though you could use any scripting language.\n</p>\n<ol><li>\nPostgreSQL database table for comments\n</li><li>\nRuby receives form posts, inserts into database\n</li><li>\nWhen comments change, PostgreSQL trigger sends NOTIFY\n</li><li>\nRuby runs PostgreSQL LISTEN, exporting updated comments to HTML\n</li><li>\nJavaScript on static page includes HTML\n</li></ol>\n\n<h2>\nPostgreSQL database table for comments\n</h2>\n<div>\n<pre><code>create table comments (\n  id integer primary key generated by default as identity,\n  uri text,\n  created_at date default current_date,\n  name text,\n  email text,\n  comment text\n);\ncreate index on comments(uri);\n</code></pre><small><a href=\"https://sive.rs/code/comments-table.sql\">download code</a></small>\n</div>\n\n<h2>\nRuby receives form posts, inserts into database\n</h2>\n\n<p>\nPut this on any HTML page where you want comments:\n</p>\n<div>\n<pre><code>&lt;section id=\"comments\"&gt;&lt;/section&gt;\n&lt;script src=\"/comments.js\"&gt;&lt;/script&gt;\n</code></pre><small><a href=\"https://sive.rs/code/comments.html.txt\">download code</a></small>\n</div>\n\n<p>\nPut this next code in your Nginx config, to send /comments to localhost.\n</p>\n<div>\n<pre><code>location = /comments {\n  proxy_pass http://127.0.0.1:4567;\n}\n</code></pre><small><a href=\"https://sive.rs/code/comments.nginx.conf\">download code</a></small>\n</div>\n\n<p>\nRuby Sinatra receives form posts.\n</p>\n<div>\n<pre><code>require 'pg'\nrequire 'sinatra'\nDB = PG::Connection.new(dbname: 'test', user: 'tester')\n\npost '/comments' do\n  DB.exec_params(\"insert into comments\n    (uri, name, email, comment)\n    values ($1, $2, $3, $4)\",\n    [params[:uri], params[:name], params[:email], params[:comment]])\n  redirect to(request.env['HTTP_REFERER'])\nend\n</code></pre><small><a href=\"https://sive.rs/code/comments-route.rb\">download code</a></small>\n</div>\n\n<p>\nRun that in a terminal on the server, and it should default to listen on port 4567.\n</p>\n\n<h2>\nWhen comments change, PostgreSQL trigger sends NOTIFY\n</h2>\n<div>\n<pre><code>create function comments_changed() returns trigger as $$\nbegin\n  perform pg_notify('comments_changed', new.uri);\n  return new;\nend;\n$$ language plpgsql;\ncreate trigger comments_changed after insert or update on comments\nfor each row execute procedure comments_changed();\n</code></pre><small><a href=\"https://sive.rs/code/comments_changed.sql\">download code</a></small>\n</div>\n\n<p>\nLoad that function into the PostgreSQL database that has your comments table.\n</p><p>\nIt sends the listener (below) a notification that comments for <strong>this URI</strong> have changed.\nThen the listener will re-output comments just for this URI, instead of all.\n</p>\n\n<h2>\nRuby runs PostgreSQL LISTEN, exporting updated comments to HTML\n</h2>\n<p>\nMake a directory in your web root called /commentcache/, to hold the static comments.\n</p><p>\nThen keep this Ruby script running in a terminal to listen for database changes, and write the updated comments to disk as HTML.\n</p>\n<div>\n<pre><code>require 'pg'\nDB = PG::Connection.new(dbname: 'test', user: 'tester')\nBASEDIR = '/var/www/htdocs/commentcache/' # directory in your web root\n\n# a single comment list entry, used in ol map, below\ndef li(row)\n  '&lt;li&gt;&lt;cite&gt;%s (%s)&lt;/cite&gt;&lt;p&gt;%s&lt;/p&gt;&lt;/li&gt;' %\n    [row['name'], row['created_at'], row['comment']]\nend\n\n# top-level map of database rows into HTML list\ndef ol(rows)\n  rows.inject('') {|html, row| html += li(row) ; html}\nend\n\n# write comments to disk for this URI\ndef save_comments(uri)\n  rows = DB.exec_params(\"select name, created_at, comment\n    from comments where uri = $1 order by id\", [uri]).to_a\n  File.open(BASEDIR + uri, 'w') do |f|\n    f.puts ol(rows)\n  end\nend\n\n# first write them all\nDB.exec(\"select distinct(uri) from comments\").each do |r|\n  save_comments(r['uri'])\nend\n\n# listen for changes. re-write when changed\nDB.exec('listen comments_changed')\nwhile true do\n  DB.wait_for_notify do |event, pid, uri|\n    save_comments(uri)\n  end\nend\n</code></pre><small><a href=\"https://sive.rs/code/comments-listen.rb\">download code</a></small>\n</div>\n\n<h2>\nJavaScript on static page includes current HTML when viewed\n</h2>\n<p>\nUse JavaScript to show the form to post a comment, and load the list of comments from the /commentcache/ path.\n</p>\n<div>\n<pre><code>function showForm(uri) {\n  document.getElementById('comments').innerHTML = `\n&lt;header&gt;&lt;h1&gt;Comments:&lt;/h1&gt;&lt;/header&gt;\n&lt;form method=\"post\" action=\"/comments\"&gt;\n&lt;input type=\"hidden\" name=\"uri\" value=\"${uri}\"&gt;\n&lt;label for=\"name\"&gt;Your Name&lt;/label&gt;\n&lt;input type=\"text\" name=\"name\" id=\"name\" required&gt;\n&lt;label for=\"email\"&gt;Your Email&lt;/label&gt;\n&lt;input type=\"email\" name=\"email\" id=\"email\" required&gt;\n&lt;label for=\"comment\"&gt;Comment&lt;/label&gt;\n&lt;textarea name=\"comment\" id=\"comment\" cols=\"80\" rows=\"10\" required&gt;&lt;/textarea&gt;\n&lt;input type=\"submit\" value=\"post comment\"&gt;\n&lt;/form&gt;\n&lt;ol id=\"commentlist\"&gt;&lt;/ol&gt;`;\n}\n\nfunction getComments(uri) {\n  try {\n    const xhr = new XMLHttpRequest();\n    xhr.open('get', '/commentcache/' + uri);\n    xhr.send(null);\n    xhr.onload = function() {\n      if (xhr.status === 200) {\n        document.getElementById('commentlist').innerHTML = xhr.responseText;\n      }\n    };\n  } catch(e) { }\n}\n\n// /blog/topic/page.html uri = 'blog_topic_page.html' for filesystem\nconst uri = location.pathname.substring(1).replace(/\\//g, '_');\nshowForm(uri);\ngetComments(uri);\n</code></pre><small><a href=\"https://sive.rs/code/comments.js\">download code</a></small>\n</div>\n\n<p>\nThat’s all.\nI’ve simplified it a bit from my real usage, where I have constraints and checks that would have distracted from the core point of this example.\n</p><p>\nThere are other ways to do it.\nThe NOTIFY and LISTEN isn’t necessary.\nThe Ruby Sinatra route that receives the posted comment could just write the HTML to disk immediately.\nBut I have other scripts that delete and update comments, and I like how <strong>the combination of NOTIFY trigger and LISTEN script always keeps them updated</strong> on disk.\n</p><p>\nAnother interesting approach would be to write the comments into each HTML file directly, instead of in a separate file, so you wouldn’t need JavaScript at all.\n</p>\n\n<h2>\nOptional upgrade: NOTIFY on delete\n</h2>\n<p>\nI simplified the PostgreSQL trigger for the example, but with a few more lines of code, you can use the same trigger to notify of deleted comments, too.\nThe value of a deleted row is in “old”, whereas inserted and updated is in “new”, so we have to make a uri variable, and an if/then/else to know which to use.\n</p>\n<div>\n<pre><code>create or replace function comments_changed() returns trigger as $$\ndeclare\n  uri text;\nbegin\n  if tg_op = 'DELETE' then\n    uri = old.uri;\n  else\n    uri = new.uri;\n  end if;\n  perform pg_notify('comments_changed', uri);\n  return old;\nend;\n$$ language plpgsql;\ncreate trigger comments_changed after insert or update or delete on comments\nfor each row execute procedure comments_changed();\n</code></pre><small><a href=\"https://sive.rs/code/comments_changed2.sql\">download code</a></small>\n</div>\n","author":"Derek Sivers","siteTitle":"Derek Sivers","siteHash":"4098504c0d0759e13901f29e63f7d7dbb1d972a078c6dc4560660f373da5c25e","entryHash":"70000cad9aade31fa0d79d4f453b335e053db494fa968c4d99bba48ec921e02e","category":"Sites"}