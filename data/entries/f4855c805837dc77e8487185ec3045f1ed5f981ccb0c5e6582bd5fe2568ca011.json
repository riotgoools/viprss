{"title":"Simplify: move code into database functions","link":"https://sive.rs/pg","date":1430697600000,"content":"<p>\nIf you are a web or API developer, programming code that uses an SQL database, this is for you.\n</p><p>\nI’ve found a very different and useful way to structure code.\nIt’s made such a big difference for me that I had to share it here.\n</p>\n<h3>\nHow things are\n</h3>\n<p>\nMost web development — whether custom or using frameworks like Rails, Django, Laravel, Sinatra, Flask, and Symfony — tends to work the same way:\n</p>\n<ul><li>\nAt the core is a <strong>database</strong>, which is just the storage of data.\n</li><li>\n<strong>All intelligence</strong> is in Ruby/Python/PHP/JavaScript classes.\n</li></ul>\n<h3>\nWhy that’s bad\n</h3>\n<p>\nThese norms have some dangerous implications:\n</p>\n<ul><li>\n<strong>Everything</strong> must go through these Ruby/Python/PHP/JavaScript classes — including shell scripts and other things not part of this application.\n</li><li>\n<strong>Nothing</strong> else may access the database directly, since doing so may break the rules defined by these surrounding classes.\n</li><li>\nThe <strong>database is treated as dumb storage</strong>, even though the database is smart enough to have most of this logic built-in.\n</li><li>\nBut if you add data logic into the database itself, it’s now <strong>duplicated</strong>, requiring changing in multiple places if the rules change.\n</li><li>\nThese two systems — the database and its surrounding code — are <strong>coupled and dependent</strong> on each other.\n</li><li>\nIf it’s ever advantageous to <strong>switch applications</strong> (say from a web app to mobile app, or Python to JavaScript), you’re going to have to <strong>re-write all of that data logic</strong>.\n</li></ul>\n<h3>\nSimple vs complex\n</h3>\n<p>\nPlease go watch this amazing 35-minute talk as soon as possible:\n<strong><a href=\"https://www.youtube.com/watch?v=rI8tNMsozo0\">Simplicity Matters by Rich Hickey</a></strong>.\n</p><p>\nHere are his important points for this article:\n</p><ul><li>\n“<strong>Complex</strong>” is objective.\nIt means <strong>many things tied together</strong>.\n</li><li>\n“<strong>Simple</strong>” is objective.\nIt means <strong>one ingredient</strong> — the opposite of complex.\n</li><li>\nThese are unrelated to “easy”.\nIt is easy to install and bind yourself to something very complex (like <a href=\"https://en.wikipedia.org/wiki/Object-relational_mapping\">ORM</a>), and can be hard to build something simple.\n</li><li>\nClasses, models, and methods (<a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\">OOP</a>) are an <strong>unnecessary complication</strong>.\n</li><li>\nInformation is simple, so <strong>don’t hide it</strong> behind a micro-language.\n</li><li>\n<strong>Work with values directly</strong>: hash/map of strings.\n</li><li>\nSince a <strong>JSON API</strong> — a hash/map of strings — is often the eventual interface, it’s even more reason to skip the abstractions and work with values directly.\n</li></ul>\n<h3>\nWhy this hit home for me\n</h3>\n<p><strong>\nDatabases outlive the applications that access them.\n</strong></p><p>\nI’ve been using the same SQL database since 1997: same data, values, and SQL tables.\nBut the code around it has changed so many times.\n</p><p>\nIn 1997, I started in Perl.\nIn 1998, I switched to PHP.\nIn 2004, a rewrite in Rails.\nIn 2007, <a href=\"https://sive.rs/rails2php\">back</a> to PHP.\nIn 2009, minimalist Ruby.\nIn 2012, client-side JavaScript.\n</p><p>\n<strong>Each time I’d have to re-write all of the logic around the database</strong>:\nhow to add a new person into the database,\nhow to verify an invoice is correct,\nhow to mark an order as paid, etc.\n</p><p>\nBut <strong>that whole time, my trusty PostgreSQL database stayed the same</strong>.\n</p><p>\nSince most of this is <a href=\"https://rob.conery.io/2015/02/21/its-time-to-get-over-that-stored-procedure-aversion-you-have/\">data logic, not business logic</a>, it should be in the database.\n</p><p>\nSo I’m putting this data logic directly into <a href=\"https://www.postgresql.org/about/\">PostgreSQL</a>, since I plan to stay with it for many more years, but plan to keep experimenting with programming languages.\n(<a href=\"https://nim-lang.org/\">Nim</a>, <a href=\"https://elixir-lang.org/\">Elixir</a>, <a href=\"https://racket-lang.org/\">Racket</a>, <a href=\"https://www.lua.org/about.html\">Lua</a>, whatever.)\n</p>\n<h3>\nHow things could be\n</h3>\n<p>\nWeb developers have been treating the database as dumb storage, but it’s actually <a href=\"https://www.postgresql.org/docs/current/server-programming.html\">quite smart</a>.\n</p><p>\nIt’s <strong>simple</strong> to have all of this intelligence <strong>in the database itself</strong>.\n</p><p>\nIt’s <strong>complex</strong> to have it tied to surrounding outside code.\n</p><p>\nOnce you put all of the intelligence directly into the database, then the outside code disappears!\n</p><p>\nThen <strong>the database is self-contained, and not tied to anything</strong>.\n</p><p>\nYour outside interface can <strong>switch</strong> to JavaScript, Haskell, Elixir or anything else with ease, because your core intelligence is all inside the database.\n</p>\n<h3>\nHow to do it\n</h3>\n<h4>\nTable constraints\n</h4>\n<p>\nThe easiest place to start is <a href=\"https://www.postgresql.org/docs/current/ddl-constraints.html\">constraints</a>:\n</p>\n<pre><code>\ncreate table people (\n  id serial primary key,\n  name text not null constraint no_name check (length(name) &gt; 0),\n  email text unique constraint valid_email check (email ~ '\\A\\S+@\\S+\\.\\S+\\Z')\n);\ncreate table tags (\n  person_id integer not null references people(id) on delete cascade,\n  tag varchar(16) constraint tag_format check (tag ~ '\\A[a-z0-9._-]+\\Z')\n);\n</code></pre>\n<p>\nDefine what is considered valid/invalid data here.\n</p><p>\nIn my people example above, it says name can’t be empty, email must match that pattern with “@” and “.” and no whitespace.\nThen it says tags.person_id has to exist in the people table, but if the person is deleted then delete the tags, too.\nAnd the tag has to fit that regexp pattern of lowercase letters, numbers, dot, underscore, dash.\n</p><p>\nIt helps to name your constraints for later use in error catching.\n</p>\n<h4>\nTriggers\n</h4>\n<p>\nFor things that happen before or after you alter data, use <a href=\"https://www.postgresql.org/docs/current/trigger-definition.html\">triggers</a>:\n</p>\n<pre><code>\ncreate function clean() returns trigger as $$\nbegin\n  new.name = btrim(regexp_replace(new.name, '\\s+', ' ', 'g'));\n  new.email = lower(regexp_replace(new.email, '\\s', '', 'g'));\nend;\n$$ language plpgsql;\ncreate trigger clean before insert or update of name, email on people\n  for each row execute procedure clean();\n</code></pre>\n<p>\nThis example cleans the input before it’s put into the database, in case someone accidentally put a space in their email address, or a line-break in their name.\n</p>\n<h4>\nFunctions\n</h4>\n<p>\nMake little re-usable functions for things you’ll use often inside your code.\n</p>\n<pre><code>\ncreate function get_person(a_name text, a_email text) returns setof people as $$\nbegin\n  if not exists (select 1 from people where email = a_email) then\n    return query insert into people (name, email)\n      values (a_name, a_email) returning people.*;\n  else\n    return query select * from people where email = a_email;\n  end if;\nend;\n$$ language plpgsql;\n</code></pre>\n<p>\nThat’s one I use often:\nGiven someone’s name and email, if they’re not already in my database, add them.\nThen, either way, return the database info for this person.\n</p>\n<h4>\nViews for JSON\n</h4>\n<p>\nInstead of requiring outside code to convert your data into JSON, you can have the <a href=\"https://www.postgresql.org/docs/current/functions-json.html#FUNCTIONS-JSON-CREATION-TABLE\">database create JSON directly</a>.\n</p><p>\nFor this, use <a href=\"https://www.postgresql.org/docs/current/sql-createview.html\">views</a> as JSON structure templates.\nInside the view, use <a href=\"https://www.postgresql.org/docs/current/functions-aggregate.html\">json_agg</a> for nested values.\n</p>\n<pre><code>\ncreate view person_view as\n  select *, (select json_agg(t) as tags from\n    (select tag from tags where person_id=people.id) t)\n  from people;\n</code></pre>\n<p>\nThis will be used in the API functions, below:\n</p>\n<h4>\nAPI functions\n</h4>\n<p>\nThese are the only functions your outside code will access.\n</p><p>\nThey return only JSON.\n</p>\n<pre><code>\ncreate function update_password(p_id integer, nu_pass text, out js json) as $$\nbegin\n  update people set password=crypt(nu_pass, gen_salt('bf', 8)) where id = p_id;\n  js := row_to_json(r) from (select * from person_view where id = p_id) r;\nend;\n$$ language plpgsql;\ncreate function people_with_tag(a_tag text, out js json) as $$\nbegin\n  js := json_agg(r) from\n    (select * from person_view where id in\n      (select person_id from tags where tag = a_tag)) r;\nend;\n$$ language plpgsql;\n</code></pre>\n<p>\nNo matter what you need to do with your database, the <a href=\"https://www.postgresql.org/docs/current/xplang.html\">procedural languages built-in to PostgreSQL</a> can do it.\n</p><p>\n<a href=\"https://www.postgresql.org/docs/current/plpgsql-overview.html\">PL/pgSQL</a> is <strong>not the most beautiful language</strong>, but the <strong>simplicity</strong> of having everything in the database is worth it.\n</p><p>\nIf you like JavaScript, check out the promising <a href=\"https://plv8.github.io/\">plv8</a>.\n</p>\n<h3>\nNow, if you need a REST API:\n</h3>\n<pre><code>\nrequire 'pg'\nrequire 'sinatra'\nDB = PG::Connection.new(dbconfig)\ndef qry(sql, params=[])\n  @res = DB.exec_params('select js from ' + sql, params)\nend\nafter do\n  content_type 'application/json'\n  body @res[0]['js']\nend\nget '/people' do\n  qry('get_people()')\nend\nget %r{/people/([0-9]+)} do |id|\n  qry('get_person($1)', [id])\nend\nput %r{/people/([0-9]+)} do |id|\n  qry('update_password($1, $2)', [id, params[:password]])\nend\nget '/people/tagged' do\n  qry('people_with_tag($1)', [params[:tag]])\nend\n</code></pre>\n<h3>\nOr if you need a client library:\n</h3>\n<pre><code>\nrequire 'pg'\nrequire 'json'\nDB = PG::Connection.new(dbconfig)\ndef js(func, params=[])\n  res = DB.exec_params('select js from ' + func, params)\n  JSON.parse(res[0]['js'])\nend\ndef people\n  js('get_people()')\nend\ndef person(id)\n  js('get_person($1)', [id])\nend\ndef update_password(id, newpass)\n  js('update_password($1, $2)', [id, newpass])\nend\ndef people_tagged(tag)\n  js('people_with_tag($1)', [tag])\nend\n</code></pre>\n<h3>\nThat’s it!\n</h3>\n<p>\nNow whether a REST API or client library, <strong>all it really has to do is pass the arguments into the database functions, and return the JSON</strong>.\n</p><p>\nI’m not trying to convince everyone to do things this way.\nBut I hope you find it useful or at least interesting to consider.\n</p>\n<img src=\"/images/postgresql.png\" alt=\"postgresql logo\" />","author":"Derek Sivers","siteTitle":"Derek Sivers","siteHash":"4098504c0d0759e13901f29e63f7d7dbb1d972a078c6dc4560660f373da5c25e","entryHash":"f4855c805837dc77e8487185ec3045f1ed5f981ccb0c5e6582bd5fe2568ca011","category":"Sites"}