{"title":"Socii Dispatch 02","link":"https://blog.webb.page/2018-02-10-socii-dispatch-02.txt","date":1518220800000,"content":"<p>TL;DR: Socii's alpha<a href=\"https://hub.socii.network\">1</a> is out in the wild and obviously <em>very</em> rough around\nthe edges. Let me tell you what I've learned since my last dispatch.</p>\n<h2>GraphQL</h2>\n<p>Yours truly, two weeks ago<a href=\"/2018-01-19-socii-dispatch-01.txt\">2</a>:</p>\n<blockquote>\n<p>GraphQL<a href=\"http://graphql.org\">3</a> is awesome. However, I've been building REST APIs for the past\nmonth and have two microservices to handle things thus far and that means\nI'm not transitioning to GraphQL until maybe version 1 of Socii is\nsolidified.</p>\n</blockquote>\n<p>HAH. Mere <em>days</em> after I published those words, I ran into an issue where I\nneeded to display comments and for those comments to show pertinent info like:</p>\n<ul>\n<li>author's<ul>\n<li>name</li>\n<li>username</li>\n<li>avatar shape</li>\n<li>avatar source</li>\n</ul>\n</li>\n</ul>\n<p>If I stuck with REST, here's what my query path would've looked like:</p>\n<ul>\n<li>query story service for original post (already have user info from earlier\nquery)</li>\n<li>query story service for comments to the original post<ul>\n<li>for each comment, query user service for comment author's aforementioned\ninfo</li>\n</ul>\n</li>\n</ul>\n<p>This is way too much work to get four pieces of info for a comment. Keep in\nmind that I'd get the <em>entire</em> user object with each query to the user service\nas well. Here's how I achieved this with GraphQL:</p>\n<pre><code>const query = `{\n  post(replyTo: \"${postId}\") {\n    author\n    content\n    createdAt\n    id\n    favoritedBy\n    notes {\n      favorites\n      replies\n      reposts\n    }\n    repliedBy\n    replyTo\n    repostedBy\n    slug\n  }\n}`;\n</code></pre>\n<p>Couple things to note here:</p>\n<ol>\n<li>GraphQL pros will tell me to use variables instead of what I'm doing here\nwith <code>postId</code> in a template literal but MEH.</li>\n<li>The <code>author</code> parameter does a little extra stuff on my GraphQL service to\nreply back with name, username, and avatar info.</li>\n<li>The post schema is quite large but I don't need all of it to display them.\nWhat you see in this query is what I get back. No wasted data, how neat is\nthat?</li>\n</ol>\n<p>This took me around three days to fully grok and to be quite honest, I am not\nreally sure if I do. ðŸ˜… It works though!</p>\n<p>There are <em>several</em> articles and dissertations out there with a clickbait-y\ntitle bemoaning the demise of REST thanks to GraphQL and wellâ€¦no. REST is\nbattle-tested and still pretty damn good. In fact, I'm still using it for\nanything that isn't a <code>GET</code> request. When you're <code>POST</code>ing or <code>PUT</code>ing, I\nthink REST reigns supreme and quite frankly, I don't feel like rewriting that\ncode.</p>\n<p>Let me have a year with ol' graphy before I do something crazy.</p>\n<h2>WebP</h2>\n<p>WebP<a href=\"https://developers.google.com/speed/webp\">4</a> is an image format invented by Google as an alternative to JPG and PNG\nfor small (but visually comparable) images. I like the idea of paying almost\nnothing for image storage so my interest was piqued early in Socii's\ndevelopment.</p>\n<p>The cost savings I've seen during testing have been massive. I had two folders\nnamed \"raw\" and \"processed\". After converting 10 or so large images\n(screenshots and the like), the \"raw\" folder was ~5MB while the \"processed\"\nfolder was ~1MB. At scale, that's some impressive cost savings. The visual\nparity was indistinguishable to me as well.</p>\n<p>Of course, Chrome is the only browser that natively supports it<a href=\"https://caniuse.com/#search=webp\">5</a>. I found a\npolyfill that works for non-Chrome users (like myself, Firefox is best for me)\nand I thought it'd be usable in production. It is <em>not</em>.</p>\n<p>I am now reversing my decision to use WebP exclusively and will optimize\nimages uploaded to Socii. Decoding WebP in the browser is slow, even with t\ne WebAssembly-converted polyfill and scrolling is horrendous. That's\n<em>terrible</em> user experience. I found another image format called FLIF<a href=\"https://github.com/FLIF-hub/FLIF\">6</a> but\nthe current polyfills are also not production-ready.</p>\n<h2>Things I've learned</h2>\n<ol>\n<li>Estimates are dumb because people are dumb. Even if you account for that,\nyou'll still be off.</li>\n<li>GraphQL is still awesome. I'm glad it took up my estimate time to learn it.</li>\n<li>We need better image formats on the web and browser vendors need to get\nonboard.</li>\n</ol>\n<p>That's all for now, see ya! ðŸ•¸</p>\n<hr />\n","author":"","siteTitle":"the webb blog","siteHash":"d87386c8de21b16d23a4d22ceb0991728c5b4e4486d627490c6fcde14e563300","entryHash":"a5fe9eff4c32a1e53d74627a02c13ef57712b913913f51f4157bb59e4ffe275c","category":"Sites"}