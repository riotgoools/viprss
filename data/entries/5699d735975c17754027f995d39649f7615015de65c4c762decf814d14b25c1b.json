{"title":"Database functions to wrap logic and SQL queries","link":"https://sive.rs/api01","date":1646006400000,"content":"<p>\nWhen you make a database-backed app, you have some functions that need to run multiple database queries.\n</p><p>\nFor example, to move money from one account to another, you have to insert a negative amount into account #1, and a positive amount into account #2.\n</p><p>\nUsually you do in your main code: your JavaScript, Python, Ruby, or whatever.\n</p><p>\nBut what if some future code bypasses your crucial “business logic” functions?\nNew code could access the database directly, without going through your existing functions.\n</p><p>\nOr what if you need to rewrite some code in a new language?\nYou’ll have a lot of data to rewrite if all this data logic was kept in the surrounding code.\n</p><p>\nI felt the pain of this at my last company, when we converted some old PHP code to Ruby.\nI had to rewrite so much of the logic.\n</p><p>\nIn hindsight, <strong>data logic should be in the database itself</strong>.\n</p><p>\nSimple logic that’s always needed to update the data (like the money-moving example) should be <strong>kept in database functions</strong>.\nThen your surrounding code - your JavaScript, Python, Ruby, or whatever - can just call these database functions, and never need to be rewritten if you change languages to Swift, Kotlin, Elixir, or whatever.\n</p><h3>\nHere’s a PostgreSQL example, from <a href=\"https://sive.rs/recalc\">my previous post</a>:\n</h3><p>\nFirst, make three simple tables:\n</p><ol><li>\nItems with prices.\n</li><li>\nLineitems with quantities.\n</li><li>\nInvoices with the total price.\n</li></ol><p>\nCreate two example items, a $5 and a $9 item.\nAnd create invoice #1 for testing.\n</p>\n<div>\n<pre><code>create table items (\n  id serial primary key,\n  price int not null check (price &gt; 0)\n);\n\ncreate table invoices (\n  id serial primary key,\n  total int\n);\n\ncreate table lineitems (\n  invoice_id int not null references invoices(id),\n  item_id int not null references items(id),\n  quantity int not null check (quantity &gt; 0),\n  primary key (invoice_id, item_id)\n);\n\n-- example data:\ninsert into items (price) values (5);\ninsert into items (price) values (9);\ninsert into invoices (total) values (0);\n</code></pre><small><a href=\"https://sive.rs/code/recalc-1.sql\">download code</a></small>\n</div>\n<p>\nIf someone wants to <strong>add an item</strong> to their cart, you need to first see if it’s in their cart already.\nIf it’s not in their cart, <strong>insert</strong> it.\nBut if that Item is in their cart, you need to <strong>update</strong> it, to add the new quantity to their existing quantity.\n</p><p>\nSo wrap all that logic in a simple <strong>function called cart_add</strong>.\n</p>\n<div>\n<pre><code>create function cart_add(inv int, item int, quant int) returns void as $$\nbegin\n  -- does this invoice + item combination already exist?\n  perform 1 from lineitems\n  where invoice_id = inv\n  and item_id = item;\n  if found then  -- yes? add this quantity\n    update lineitems\n    set quantity = quantity + quant\n    where invoice_id = inv\n    and item_id = item;\n  else  -- no? insert\n    insert into lineitems values (inv, item, quant);\n  end if;\nend;\n$$ language plpgsql;\n</code></pre><small><a href=\"https://sive.rs/code/api01-1.sql\">download code</a></small>\n</div>\n<p>\nSomeone updates their cart, to <strong>change the quantity</strong> of a Lineitem.\nIf they change the quantity to 2, 5, or even 1, no problem, just <strong>update</strong> the quantity.\nBut what if they change the quantity to 0?\nYou don’t want a Lineitem hanging around their cart with a quantity of 0.\nNo, if the quantity is 0 or below, you want to <strong>delete</strong> that Lineitem.\n</p><p>\nSo wrap all that logic in a simple <strong>function called cart_set</strong>.\n</p>\n<div>\n<pre><code>-- update the quantity of an item in the cart\ncreate function cart_set(inv int, item int, quant int) returns void as $$\nbegin\n  if quant &gt; 0 then\n    update lineitems\n    set quantity = quant\n    where invoice_id = inv\n    and item_id = item;\n  else  -- quantity 0 or below? delete\n    delete from lineitems\n    where invoice_id = inv\n    and item_id = item;\n  end if;\nend;\n$$ language plpgsql;\n</code></pre><small><a href=\"https://sive.rs/code/api01-2.sql\">download code</a></small>\n</div>\n<p>\nThere, now this data logic is where it belongs: with the data itself.\n</p><p>\nYour JavaScript, Python, Ruby, or whatever can just call the functions, like this:\n</p>\n<div>\n<pre><code>select cart_add(1, 1, 3);\nselect * from lineitems;\n\nselect cart_add(1, 2, 4);\nselect * from lineitems;\n\nselect cart_set(1, 2, 1);\nselect * from lineitems;\n</code></pre><small><a href=\"https://sive.rs/code/api01-3.sql\">download code</a></small>\n</div>\n<p>\nImagine if you did it like this for all of the important things you need to do in your database?\n</p><p>\nThen any code, in any language, could just call those functions, knowing the database itself will handle the logic.\nKeeping the data-logic where it should be: with the data.\n</p><p>\nDownload the final example file here: <a href=\"https://sive.rs/code/api01.sql\">/code/api01.sql</a>.\n</p><p>\nMore on this in future posts.\nOr until then, see my <a href=\"https://github.com/sivers/store\">example on Github</a>.\n</p>\n","author":"Derek Sivers","siteTitle":"Derek Sivers","siteHash":"4098504c0d0759e13901f29e63f7d7dbb1d972a078c6dc4560660f373da5c25e","entryHash":"5699d735975c17754027f995d39649f7615015de65c4c762decf814d14b25c1b","category":"default"}